module.exports = function(RED) {
    var mqtt = require('mqtt');
    
    function Triplets(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        this.payload = config.payload;
        this.topic = config.topic;
        this.qos = parseInt(config.qos || 0);
        this.prompt = config.prompt;
        this.objective = config.objective;
        this.templates = config.templates || [];
        this.apiEndpoint = config.apiEndpoint;
        this.functions = config.functions || [];
        this.functionObjects = [];
        this.debugEnabled = config.debugEnabled || false;
        this.debugLogs = [];
        this.maxLogEntries = 500;
        
        // Function to add debug logs
        this.log = function(message, data) {
            if (this.debugEnabled) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    message: message,
                    data: data || null
                };
                
                this.debugLogs.unshift(logEntry);
                
                if (this.debugLogs.length > this.maxLogEntries) {
                    this.debugLogs.pop();
                }

                if (this.debugLogs.length > 0) {
                    RED.comms.publish("debug-log:" + this.id, this.debugLogs);
                }
            }
        };
        
        if (this.functions.length > 0) {
            this.functions.forEach(function(functionDef) {
                try {
                    var functionObject = Function('msg', 'node', 'context', 'flow', 'global', functionDef.code);
                    node.functionObjects.push({
                        name: functionDef.name,
                        func: functionObject
                    });
                } catch(err) {
                    node.error("Error in tool '" + functionDef.name + "': " + err.toString());
                    node.warn("Tool '" + functionDef.name + "' disabled due to error");
                    node.log("Error in tool: " + functionDef.name, err.toString());
                }
            });
        }
        
        // Default status - MQTT is now always part of the default status
        this.status({fill:'yellow', shape:'ring', text:'connecting to mqtt...'});
        
        // Set up MQTT subscription - always enabled
        this.broker = RED.nodes.getNode(config.broker);

        if (this.broker) {
            try {
                // Instead of using broker.connect(), create our own MQTT client:
                var options = {
                    clientId: 'triplet_' + Math.random().toString(16).substring(2, 8),
                    clean: true
                };
                
                // Get connection details from broker config
                var brokerUrl = 'mqtt://' + this.broker.broker + ':' + this.broker.port;
                
                node.log("Connecting to MQTT broker", brokerUrl);
                
                // Create MQTT client directly
                this.client = mqtt.connect(brokerUrl, options);
                
                if (this.client) {
                    this.client.on('connect', function() {
                        node.status({fill:"green", shape:"dot", text:"mqtt connected"});
                        node.log("MQTT connected", node.broker.broker + ":" + node.broker.port);
                        
                        if (node.topic) {
                            node.client.subscribe(node.topic, {qos: node.qos});
                            node.log("Subscribed to topic", node.topic);
                        } else {
                            node.warn("MQTT topic not specified");
                            node.log("No MQTT topic specified", null);
                        }
                    });

                    this.client.on('message', function(topic, message) {
                        try {
                            node.log("MQTT message received", {topic: topic});
                            // Create a new message object from the MQTT message
                            var msg = {
                                topic: topic,
                                payload: message.toString()
                            };
                            
                            // Try to parse payload as JSON
                            try {
                                msg.payload = JSON.parse(msg.payload);
                                node.log("Parsed JSON payload", null);
                            } catch (parseError) {
                                // If not valid JSON, keep as string
                                node.warn("MQTT message is not valid JSON, using as string");
                                node.log("Failed to parse JSON", parseError.toString());
                            }
                            
                            // Mark message as processed by triplets
                            msg.processed_by_triplets = true;
                            
                            // Process with tools first
                            msg = processWithFunctions(msg);
                            
                            // Generate triplets
                            var generatedTriplets = [];
                            var storeTriplets = [];
                            
                            node.templates.forEach(function(template) {
                                if (template.subject && template.predicate && template.object) {
                                    // Generate triplet
                                    var triplet = {
                                        subject: template.subject,
                                        predicate: template.predicate,
                                        object: template.object
                                    };
                                    
                                    // Apply dynamic values if needed
                                    if (typeof msg.payload === 'object') {
                                        for (var key in triplet) {
                                            if (triplet[key].startsWith('msg.')) {
                                                var path = triplet[key].substring(4).split('.');
                                                var value = msg;
                                                
                                                // Navigate the path
                                                for (var i = 0; i < path.length; i++) {
                                                    if (value === undefined || value === null) break;
                                                    value = value[path[i]];
                                                }
                                                
                                                // Set the triplet value if path resolved
                                                if (value !== undefined && value !== null) {
                                                    triplet[key] = value.toString();
                                                }
                                            }
                                        }
                                    }
                                    
                                    node.log("Generated triplet", triplet);
                                    
                                    // Add to generated triplets
                                    generatedTriplets.push(triplet);
                                    
                                    // Add to store triplets if template has storage enabled
                                    if (template.enableStorage && node.apiEndpoint) {
                                        storeTriplets.push(triplet);
                                    }
                                }
                            });
                            
                            // Add triplets to message
                            if (generatedTriplets.length > 0) {
                                if (!msg.triplets) {
                                    msg.triplets = [];
                                }
                                
                                msg.triplets = msg.triplets.concat(generatedTriplets);
                                node.log("Added triplets to message", {count: generatedTriplets.length});
                                
                                // Update the prompt with triplet templates if it exists
                                if (node.prompt) {
                                    msg.prompt = node.prompt;
                                    
                                    // Append each triplet definition to the prompt
                                    generatedTriplets.forEach(function(triplet) {
                                        msg.prompt += "\nTriplet: " + triplet.subject + " - " + triplet.predicate + " - " + triplet.object;
                                    });
                                }
                                
                                // Try to store triplets if any are marked for storage
                                if (storeTriplets.length > 0 && node.apiEndpoint) {
                                    try {
                                        // Prepare storage request with timestamp
                                        var storageRequest = {
                                            triplets: storeTriplets,
                                            timestamp: new Date().toISOString()
                                        };
                                        
                                        // Send storage request
                                        // This would typically be an HTTP request, but we're just logging for now
                                        node.warn("Would store " + storeTriplets.length + " triplets to: " + node.apiEndpoint);
                                        node.status({fill:"blue", shape:"dot", text:"mqtt: storing " + storeTriplets.length});
                                        node.log("Storing triplets", {count: storeTriplets.length, endpoint: node.apiEndpoint});
                                    } catch (storeError) {
                                        node.error("Error storing triplets: " + storeError.toString());
                                        node.log("Error storing triplets", storeError.toString());
                                    }
                                }
                            }
                            
                            // Include prompt and objective if set (only if not already set by triplets)
                            if (node.prompt && !msg.prompt) {
                                msg.prompt = node.prompt;
                                // Also add to payload for easier access
                                if (typeof msg.payload === 'object') {
                                    msg.payload.prompt = node.prompt;
                                }
                            }
                            
                            if (node.objective) {
                                msg.objective = node.objective;
                                // Also add to payload for easier access
                                if (typeof msg.payload === 'object') {
                                    msg.payload.objective = node.objective;
                                }
                            }
                            
                            // Store message in history file
                            (function() {
                            try {
                                var fs = require('fs');
                                var path = require('path');
                                    
                                    // Define path to the public directory and history file
                                    var userDir = RED.settings.userDir || process.cwd();
                                    var publicDir = path.join(userDir, 'public');
                                    var dataDir = path.join(publicDir, 'data');
                                    var historyFilePath = path.join(dataDir, 'message_history.json');
                                    
                                    // Ensure directories exist
                                    if (!fs.existsSync(publicDir)) {
                                        console.log("Creating public directory:", publicDir);
                                        fs.mkdirSync(publicDir, { recursive: true });
                                    }
                                    
                                if (!fs.existsSync(dataDir)) {
                                        console.log("Creating data directory:", dataDir);
                                    fs.mkdirSync(dataDir, { recursive: true });
                                }
                                
                                    // Create history object structure
                                    var history = {
                                        node_messages: {}
                                    };
                                    
                                    // Try to read existing history file
                                if (fs.existsSync(historyFilePath)) {
                                    try {
                                        var fileContent = fs.readFileSync(historyFilePath, 'utf8');
                                            if (fileContent && fileContent.trim()) {
                                            history = JSON.parse(fileContent);
                                                // Ensure structure exists
                                                if (!history.node_messages) {
                                                    history.node_messages = {};
                                                }
                                            }
                                        } catch (readError) {
                                            console.error("Error reading message history file:", readError);
                                            // Continue with new history object
                                        }
                                    } else {
                                        console.log("Creating new history file:", historyFilePath);
                                }
                                
                                // Get or create array for this node's messages
                                var nodeMessages = history.node_messages[node.id] || [];
                                
                                    // Create a safe copy of the message that can be stringified
                                    var safeMsg = {};
                                    try {
                                        // Simple JSON serialization/deserialization makes a safe copy
                                        safeMsg = JSON.parse(JSON.stringify(msg));
                                    } catch (jsonError) {
                                        // If message can't be serialized, create a basic object
                                        safeMsg = { 
                                            payload: typeof msg.payload === 'object' ? 
                                                "Complex object - see node output" : msg.payload,
                                            topic: msg.topic
                                        };
                                    }
                
                // Add current message to history with timestamp
                var historyEntry = {
                    timestamp: new Date().toISOString(),
                                        data: safeMsg
                };
                
                                    // Add to beginning (newest first)
                nodeMessages.unshift(historyEntry);
                
                                    // Update history object
                history.node_messages[node.id] = nodeMessages;
                
                                    // Write to file with pretty formatting
                fs.writeFileSync(historyFilePath, JSON.stringify(history, null, 2));
                
                                    // Publish to editor for real-time updates
                                    RED.comms.publish("triplets/output/" + node.id, safeMsg);
                                    
                                    console.log("Saved message to history for node", node.id);
                                    
                                } catch (error) {
                                // Add current message to history with timestamp
                                var historyEntry = {
                                    timestamp: new Date().toISOString(),
                                    data: msg
                                };
                                
                                // Add to beginning (newest first) - NO LIMIT
                                nodeMessages.unshift(historyEntry);
                                
                                // Update history object with ALL messages
                                history.node_messages[node.id] = nodeMessages;
                                
                                // Save ALL messages to file
                                fs.writeFileSync(historyFilePath, JSON.stringify(history, null, 2));
                                
                                // Also publish to editor via comms for real-time updates
                                RED.comms.publish("triplets/output/" + node.id, msg);
                                
                            } catch(e) {
                                node.error("Error saving message to history: " + e.toString());
                            }
                            
                            // Send the constructed message
                            node.send(msg);
                            node.log("Message sent", null);
                            
                        } catch (err) {
                            node.error("Error processing MQTT message: " + err.toString());
                            node.log("Error processing MQTT message", err.toString());
                        }
                    });

                    this.client.on('close', function() {
                        node.status({fill:'red', shape:'ring', text:'mqtt disconnected'});
                        node.log("MQTT disconnected", null);
                    });

                    this.client.on('error', function(err) {
                        node.status({fill:'red', shape:'ring', text:'mqtt error'});
                        node.error("MQTT error: " + err.toString());
                        node.log("MQTT error", err.toString());
                    });

                    this.on('close', function(done) {
                        node.log("Node closing", null);
                        if (node.client) {
                            if (node.topic) {
                                node.client.unsubscribe(node.topic);
                            }
                            node.client.end(true, done);
                        } else {
                            done();
                        }
                    });
                } else {
                    node.error("Failed to create MQTT client");
                    this.status({fill:'red', shape:'ring', text:'mqtt client creation failed'});
                    node.log("Failed to create MQTT client", null);
                }
            } catch (err) {
                node.error("Error creating MQTT client: " + err.toString());
                this.status({fill:'red', shape:'ring', text:'mqtt setup error'});
                node.log("Error creating MQTT client", err.toString());
            }
        } else {
            node.error("MQTT broker not configured");
            this.status({fill:'red', shape:'ring', text:'mqtt broker not configured'});
            node.log("MQTT broker not configured", null);
        }

        // Function to process message with tools
        function processWithFunctions(msg) {
            if (node.functionObjects && node.functionObjects.length > 0) {
                try {
                    node.log("Processing message with tools", {toolCount: node.functionObjects.length});
                    for (var i = 0; i < node.functionObjects.length; i++) {
                        var funcObj = node.functionObjects[i];
                        try {
                            node.log("Running tool", {name: funcObj.name});
                            // Call the function with context access
                            var result = funcObj.func(msg, node, node.context(), node.context().flow, node.context().global);
                            
                            // Update the message object if a result was returned
                            if (result !== null && result !== undefined) {
                                msg = result;
                                node.log("Tool returned result", {name: funcObj.name});
                            } else {
                                node.warn("Tool '" + funcObj.name + "' did not return a message object");
                                node.log("Tool did not return message", {name: funcObj.name});
                            }
                        } catch (err) {
                            node.error("Error in tool '" + funcObj.name + "': " + err.toString(), msg);
                            node.warn("Continuing with other tools");
                            node.log("Error in tool", {name: funcObj.name, error: err.toString()});
                        }
                    }
                } catch (err) {
                    node.error("Error processing tools: " + err.toString(), msg);
                    node.log("Error processing tools", err.toString());
                }
            }
            return msg;
        }

        // Handle normal input flow messages
        this.on("input", function(msg, send, done) {
            node.log("Received input message", {topic: msg.topic});
            
            // Apply configured payload if set
            if (node.payload) {
                msg.payload = node.payload;
                node.log("Applied configured payload", null);
            }
            
            // Mark message as processed
            msg.processed_by_triplets = true;
            
            // Process with tools
            try {
                msg = processWithFunctions(msg);
            } catch (err) {
                node.error("Error running tools: " + err.toString(), msg);
                node.log("Error running tools", err.toString());
            }
            
            // Create a text representation of triplet templates to add to the prompt
            var templatesText = "Knowledge Triplet Templates:\n";
            
            node.templates.forEach(function(template) {
                templatesText += `${template.subject} ${template.predicate} [${template.object}]\n`;
            });
            
            // Store the templates text for use in the prompt
            msg.templatesText = templatesText;
            
            // Store the original prompt if set
            var originalPrompt = node.prompt || '';
            
            // If prompt is already set, append the templates
            if (originalPrompt) {
                msg.prompt = originalPrompt + "\n\n" + templatesText;
            } else {
                msg.prompt = templatesText;
            }
            
            // Also add to payload for easier access
            if (typeof msg.payload === 'object') {
                msg.payload.templatesText = templatesText;
                msg.payload.prompt = msg.prompt;
            }
            
            var triplets = [];
            var storeTriplets = []; // Separate array for triplets to be stored
            var data = {};
            
            // Extract data from payload
            if (typeof msg.payload === 'object') {
                data = msg.payload;
            } else if (typeof msg.payload === 'string') {
                try {
                    data = JSON.parse(msg.payload);
                    node.log("Parsed payload string as JSON", null);
                } catch(e) {
                    data = { value: msg.payload };
                    node.log("Could not parse payload as JSON, using as value", null);
                }
            } else {
                data = { value: msg.payload };
                node.log("Using non-object payload as value", null);
            }
            
            // Process each template to extract triplets
            node.templates.forEach(function(template) {
                // Extract path from object field if it exists
                if (template.subject && template.predicate && template.object) {
                    var objectPath = template.object;
                    var value;
                    
                    // Handle dynamic paths (msg.payload.something)
                    if (objectPath.startsWith('msg.')) {
                        var path = objectPath.substring(4).split('.');
                        value = msg;
                        
                        // Navigate the path
                        for (var i = 0; i < path.length; i++) {
                            if (value === undefined || value === null) break;
                            value = value[path[i]];
                        }
                    } else {
                        // Try direct access from data
                        value = data[objectPath];
                    }
                    
                    // Create the triplet if value was found
                    if (value !== undefined && value !== null) {
                        // Convert to string if needed
                        if (typeof value !== 'string') {
                            value = value.toString();
                        }
                        
                        var triplet = {
                            subject: template.subject,
                            predicate: template.predicate,
                            object: value
                        };
                        
                        node.log("Created triplet from template", triplet);
                        
                        // Add to all triplets array
                        triplets.push(triplet);
                        
                        // If this template has storage enabled, add to the store array
                        if (template.enableStorage && node.apiEndpoint) {
                            storeTriplets.push(triplet);
                        }
                    } else {
                        node.log("Could not resolve value for template", {
                            subject: template.subject,
                            predicate: template.predicate,
                            objectPath: objectPath
                        });
                    }
                }
            });
            
            // Add triplets to message for storage and other uses
            msg.triplets = triplets;
            node.log("Added triplets to message", {count: triplets.length});
            
            // Store triplets that are marked for storage
            if (storeTriplets.length > 0 && node.apiEndpoint) {
                try {
                    // Create storage request
                    var storageMsg = {
                        url: node.apiEndpoint,
                        method: "POST",
                        payload: {
                            triplets: storeTriplets,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                    // Log the storage attempt
                    node.status({fill:"green", shape:"dot", text:"storing triplets: " + storeTriplets.length});
                    
                    // Include storage message
                    msg.storageRequest = storageMsg;
                    node.log("Created storage request", {endpoint: node.apiEndpoint, count: storeTriplets.length});
                } catch(err) {
                    node.error("Error preparing storage: " + err.toString(), msg);
                    node.status({fill:"red", shape:"ring", text:"storage error"});
                    node.log("Error preparing storage", err.toString());
                }
            }
            
            // Include prompt and objective if set (only if not already set by triplets)
            if (node.prompt && !msg.prompt) {
                msg.prompt = node.prompt;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.prompt = node.prompt;
                }
            }
            
            if (node.objective) {
                msg.objective = node.objective;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.objective = node.objective;
                }
            }
            
            // Handle MQTT topic changes - always enabled
            if (node.client && msg.mqtt_control) {
                if (msg.mqtt_control === 'subscribe' && msg.topic) {
                    // Subscribe to a new topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                        }
                        node.topic = msg.topic;
                        node.client.subscribe(node.topic, {qos: node.qos});
                        node.status({fill:"green", shape:"dot", text:"mqtt: " + node.topic});
                        node.log("Changed MQTT subscription", {topic: node.topic});
                    } catch(err) {
                        node.error("Error changing subscription: " + err.toString());
                        node.log("Error changing subscription", err.toString());
                    }
                }
                else if (msg.mqtt_control === 'unsubscribe') {
                    // Unsubscribe from current topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                            node.topic = '';
                            node.status({fill:"yellow", shape:"dot", text:"mqtt: no subscription"});
                            node.log("Unsubscribed from MQTT topic", null);
                        }
                    } catch(err) {
                        node.error("Error unsubscribing: " + err.toString());
                        node.log("Error unsubscribing", err.toString());
                    }
                }
            }
            
            // Store ALL messages in history file
            try {
                // Define path to history file
                var fs = require('fs');
                var path = require('path');
                var historyFilePath = path.join(RED.settings.userDir || process.cwd(), 'public', 'data', 'message_history.json');
                
                // Create data directory if it doesn't exist
                var dataDir = path.dirname(historyFilePath);
                if (!fs.existsSync(dataDir)) {
                    fs.mkdirSync(dataDir, { recursive: true });
                }
                
                // Read existing history (or create new object)
                var history = { node_messages: {} };
                if (fs.existsSync(historyFilePath)) {
                    try {
                        var fileContent = fs.readFileSync(historyFilePath, 'utf8');
                        if (fileContent.trim()) {
                            history = JSON.parse(fileContent);
                        }
                    } catch(e) {
                        node.error("Error reading message history file: " + e.toString());
                        // Continue with empty history object
                    }
                }
                
                // Make sure the node_messages object exists
                if (!history.node_messages) {
                    history.node_messages = {};
                }
                
                // Get or create array for this node's messages
                var nodeMessages = history.node_messages[node.id] || [];
                
                // Add current message to history with timestamp
                var historyEntry = {
                    timestamp: new Date().toISOString(),
                    data: msg
                };
                
                // Add to beginning (newest first) - NO LIMIT
                nodeMessages.unshift(historyEntry);
                
                // Update history object with ALL messages
                history.node_messages[node.id] = nodeMessages;
                
                // Save ALL messages to file
                fs.writeFileSync(historyFilePath, JSON.stringify(history, null, 2));
                
                // Also publish to editor via comms for real-time updates
                RED.comms.publish("triplets/output/" + node.id, msg);
                
            } catch(e) {
                node.error("Error saving message to history: " + e.toString());
            }
            
            // Send the message
            if (send) {
                send(msg);
            } else {
                node.send(msg);
            }
            node.log("Message sent", null);
            
            if (done) {
                done();
            }
        });
    }
    
    RED.nodes.registerType("triplets", Triplets);
    
    // Clear logs when requested from the editor
    RED.httpAdmin.post("/triplets/:id/clearLogs", RED.auth.needsPermission("triplets.write"), function(req, res) {
        var node = RED.nodes.getNode(req.params.id);
        if (node && node.type === "triplets") {
            node.debugLogs = [];
            RED.comms.publish("debug-log:" + node.id, []);
            res.sendStatus(200);
        } else {
            res.sendStatus(404);
        }
    });
    
    // Get logs for a node
    RED.httpAdmin.get("/triplets/:id/logs", RED.auth.needsPermission("triplets.read"), function(req, res) {
        var node = RED.nodes.getNode(req.params.id);
        if (node && node.type === "triplets") {
            res.json(node.debugLogs);
        } else {
            res.sendStatus(404);
        }
    });
    
    // Add client-side resources for the custom property panel
    RED.hooks.add("editorTheme", {
        resources: function() {
            return [
                {
                    name: "triplets-editor", 
                    path: "custom/triplets/",
                    files: ["js/triplets-editor.js", "css/triplets-editor.css"]
                }
            ];
        }
    });
}