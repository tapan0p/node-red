<script type="text/javascript">
    RED.nodes.registerType('conditional-edge',{
        category: 'custom',
        color: '#E2D96E',
        defaults: {
            property: {value:"triplets", required:true},
            propertyType: {value:"msg"},
            rules: {value:[{t:"eq", v:"", vt:"str"}]},
            checkall: {value:"true", required:true},
            target: {value:"subject"},
            targetValue: {value:""}
        },
        inputs:1,
        outputs:1,
        align: "center",
        label: function() {
            return "\u200B"; // Zero-width space character - invisible but not empty
        },
        labelStyle: function() {
            return "display:none !important;font-size:0px;opacity:0;visibility:hidden;";
        },
        paletteLabel: "\u200B", // Zero-width space for palette too
        icon: false, // Disable icon
        nodeName: "\u200B", // Set empty node name
        descriptionText: "\u200B", // Set empty description
        size: "small", // Set small size
        oneditprepare: function() {
            // Add CSS to completely hide node labels and make the node very small
            $("<style>")
                .prop("type", "text/css")
                .html(`
                    .red-ui-palette-node[data-type="conditional-edge"] .red-ui-palette-label,
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-label {
                        display: none !important;
                        visibility: hidden !important;
                        opacity: 0 !important;
                        width: 0 !important;
                        height: 0 !important;
                        font-size: 0 !important;
                    }
                    
                    /* Make the node very small */
                    .red-ui-node[data-type="conditional-edge"] {
                        width: 10px !important;
                        min-width: 10px !important;
                        height: 20px !important;
                        border-radius: 5px !important;
                    }
                    
                    /* Adjust the port positions for the small node */
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-port {
                        top: 10px !important;
                    }
                    
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-input {
                        left: -5px !important;
                    }
                    
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-output {
                        right: -5px !important;
                    }
                `)
                .appendTo("head");
            
            var node = this;
            
            // Define available operators
            var operators = [
                {v:"eq", t:"equals", kind:'V'},
                {v:"neq", t:"not equals", kind:'V'},
                {v:"lt", t:"less than", kind:'V'},
                {v:"lte", t:"less or equal to", kind:'V'},
                {v:"gt", t:"greater than", kind:'V'},
                {v:"gte", t:"greater or equal to", kind:'V'},
                {v:"contains", t:"contains", kind:'V'},
                {v:"startsWith", t:"starts with", kind:'V'},
                {v:"endsWith", t:"ends with", kind:'V'},
                {v:"true", t:"is true", kind:'V'},
                {v:"false", t:"is false", kind:'V'},
                {v:"null", t:"is null", kind:'V'},
                {v:"not-null", t:"is not null", kind:'V'},
                {v:"typeof", t:"is of type", kind:'V'}
            ];

            // Create typedInput for property
            var propertyInput = $("#node-input-property");
            propertyInput.typedInput({
                default: 'msg',
                types: ['msg'],
                typeField: $("#node-input-propertyType")
            });
            
            // Set up the rules container
            var rulesContainer = $("#node-input-rule-container");
            var rulesData = node.rules || [{t:"eq", v:"", vt:"str"}];
            
            // Function to create a rule row
            function createRuleRow(rule) {
                var container = $("<li/>", {class:"rule-container", style:"margin-bottom: 5px; padding: 10px; border: 1px solid #ccc; border-radius: 4px;"});
                
                // Create the operator select
                var operatorRow = $("<div/>", {class:"form-row", style:"margin-bottom: 5px;"});
                $("<label/>").text("If object value").appendTo(operatorRow);
                
                var operatorSelect = $("<select/>", {class:"rule-operator", style:"width:35%;"}).appendTo(operatorRow);
                
                // Add operators to select
                for (var d in operators) {
                    operatorSelect.append($("<option></option>").val(operators[d].v).text(operators[d].t));
                }
                
                // Set the selected operator
                operatorSelect.val(rule.t);
                
                // Create the value input field
                var valueRow = $("<div/>", {class:"form-row", style:"margin-top: 5px;"});
                $("<label/>").text("Value").appendTo(valueRow);
                
                var valueField = $("<input/>", {
                    class:"rule-value", 
                    type:"text", 
                    style:"width:70%;"
                }).appendTo(valueRow);
                
                // Set up the typedInput for value
                valueField.typedInput({
                    default: rule.vt || 'str',
                    types: ['msg', 'flow', 'global', 'str', 'num', 'bool'],
                    typeField: $("<input/>", {type:"hidden"})
                });
                
                // Set the value
                valueField.typedInput('value', rule.v);
                
                // Delete button row
                var deleteRow = $("<div/>", {class:"form-row", style:"margin-top: 5px; text-align: right;"});
                var deleteButton = $("<button/>", {
                    class:"ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only", 
                    style:"margin: 0; padding: 4px 10px; font-size: 11px;"
                }).text("Delete").appendTo(deleteRow);
                
                deleteButton.click(function() {
                    container.remove();
                });
                
                // Add rows to container
                container.append(operatorRow).append(valueRow).append(deleteRow);
                
                // Disable value input for operators that don't need values
                if (rule.t === "true" || rule.t === "false" || rule.t === "null" || rule.t === "not-null") {
                    valueRow.hide();
                }
                
                // Handle operator change
                operatorSelect.change(function() {
                    var op = $(this).val();
                    if (op === "true" || op === "false" || op === "null" || op === "not-null") {
                        valueRow.hide();
                    } else {
                        valueRow.show();
                    }
                });
                
                return container;
            }
            
            // Add existing rules or default rule
            for (var i = 0; i < rulesData.length; i++) {
                var rule = rulesData[i];
                createRuleRow(rule).appendTo(rulesContainer);
            }
            
            // Add button for rules
            $("#node-input-add-rule").click(function() {
                createRuleRow({t:"eq", v:"", vt:"str"}).appendTo(rulesContainer);
            });
            
            // Setup target filter type
            $("#node-input-target").change(function() {
                if ($(this).val() === "all") {
                    $("#node-row-target-value").hide();
                } else {
                    $("#node-row-target-value").show();
                }
            });
            
            // Initialize target visibility
            if (this.target === "all") {
                $("#node-row-target-value").hide();
            }
        },
        oneditsave: function() {
            var node = this;
            var rules = [];
            
            $(".rule-container").each(function() {
                var container = $(this);
                
                var operator = container.find(".rule-operator").val();
                var valueField = container.find(".rule-value");
                var value = valueField.typedInput('value');
                var valueType = valueField.typedInput('type');
                
                // Only include the value for operators that need it
                if (operator === "true" || operator === "false" || operator === "null" || operator === "not-null") {
                    rules.push({t: operator});
                } else {
                    rules.push({
                        t: operator,
                        v: value,
                        vt: valueType
                    });
                }
            });
            
            node.rules = rules;
        }
    });
</script>

<script type="text/html" data-template-name="conditional-edge">
    <div class="form-row">
        <label for="node-input-property"><i class="fa fa-list"></i> Triplets</label>
        <input type="text" id="node-input-property">
        <input type="hidden" id="node-input-propertyType">
    </div>
    
    <div class="form-row">
        <label for="node-input-target"><i class="fa fa-filter"></i> Filter by</label>
        <select id="node-input-target" style="width:70%;">
            <option value="all">All triplets</option>
            <option value="subject">Subject</option>
            <option value="predicate">Predicate</option>
            <option value="object">Object</option>
        </select>
    </div>
    
    <div class="form-row" id="node-row-target-value">
        <label for="node-input-targetValue"><i class="fa fa-crosshairs"></i> Value</label>
        <input type="text" id="node-input-targetValue" placeholder="Value to filter triplets" style="width:70%;">
    </div>
    
    <div class="form-row">
        <label><i class="fa fa-list-ol"></i> Rules</label>
        <button id="node-input-add-rule" type="button" class="ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only" style="float: right; margin-right: 10px;">
            <span class="ui-button-text">Add</span>
        </button>
    </div>
    
    <div class="form-row node-input-rule-container-row">
        <ol id="node-input-rule-container" style="list-style-type:none; padding-left: 0;"></ol>
    </div>
    
    <div class="form-row">
        <label for="node-input-checkall"><i class="fa fa-check-square-o"></i> If multiple rules</label>
        <select id="node-input-checkall" style="width:70%;">
            <option value="true">All rules must match</option>
            <option value="false">Any rule can match</option>
        </select>
    </div>
</script>

<script type="text/html" data-help-name="conditional-edge">
    <p>A node that acts as a conditional edge for knowledge graph triplets.</p>
    
    <h3>Properties</h3>
    <dl class="message-properties">
        <dt>Triplets <span class="property-type">msg.triplets</span></dt>
        <dd>The property containing the triplet data to evaluate.</dd>
        
        <dt>Filter by</dt>
        <dd>Filter triplets by subject, predicate, object, or evaluate all triplets.</dd>
        
        <dt>Value</dt>
        <dd>The specific value to filter triplets by (when filter is not "All triplets").</dd>
        
        <dt>Rules</dt>
        <dd>Conditions that triplet values must satisfy for the message to pass through.</dd>
        
        <dt>If multiple rules</dt>
        <dd>Whether all rules must match (AND) or any rule can match (OR).</dd>
    </dl>
    
    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>msg.triplets</dt>
        <dd>An array of triplet objects with subject, predicate, and object properties.</dd>
    </dl>
    
    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>msg</dt>
        <dd>The original message passes through if conditions are met, otherwise no output.</dd>
    </dl>
    
    <h3>Details</h3>
    <p>This node evaluates conditions against knowledge graph triplet data. It acts as a filter that only allows messages to pass through when the specified conditions are met.</p>
    
    <p>Triplets are expected to have the following format:</p>
    <pre>[
  {
    "subject": "patient",
    "predicate": "hasTemperature",
    "object": 37.5
  },
  ...
]</pre>
    
    <p>You can filter triplets by subject, predicate, or object value before applying the rules. For example, you might only want to evaluate rules against triplets with subject "patient".</p>
    
    <p>Rules are evaluated against the "object" property of the triplets, as this typically contains the value being analyzed.</p>
</script> 