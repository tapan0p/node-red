module.exports = function(RED) {
    var mqtt = require('mqtt');

    function Triplets(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        this.payload = config.payload;
        this.enableMqtt = config.enableMqtt;
        this.topic = config.topic;
        this.qos = parseInt(config.qos || 0);
        
        // New properties
        this.prompt = config.prompt;
        this.objective = config.objective;
        this.customFunction = config.customFunction;
        
        // Knowledge graph triplet templates - modified format
        this.enableTemplates = config.enableTemplates;
        this.templates = config.templates || [];
        
        // Storage options
        this.enableStorage = config.enableStorage;
        this.storageType = config.storageType || "database";
        this.apiEndpoint = config.apiEndpoint;
        
        // Compile custom function if provided
        if (this.customFunction) {
            try {
                this.processFunction = new Function('msg', 'node', this.customFunction);
            } catch(err) {
                this.error("Error compiling custom function: " + err.toString());
                this.processFunction = null;
            }
        }
        
        // Default status - input handler only
        this.status({fill:'blue', shape:'dot', text:'input handler'});
        
        // Set up MQTT subscription only if explicitly enabled
        if (this.enableMqtt) {
        this.broker = RED.nodes.getNode(config.broker);

            if (this.broker) {
                this.status({fill:'yellow', shape:'ring', text:'connecting...'});
                
                try {
                    // Instead of using broker.connect(), create our own MQTT client:
                    var options = {
                        clientId: 'triplet_' + Math.random().toString(16).substring(2, 8),
                        clean: true
                    };
                    
                    // Get connection details from broker config
                    var brokerUrl = 'mqtt://' + this.broker.broker + ':' + this.broker.port;
                    
                    // Create MQTT client directly
                    this.client = mqtt.connect(brokerUrl, options);
                    
                    if (this.client) {
                        this.client.on('connect', function() {
                            node.status({fill:"green", shape:"dot", text:"mqtt+input"});
                            
                            if (node.topic) {
                                node.client.subscribe(node.topic, {qos: node.qos});
                            } else {
                                node.warn("MQTT enabled but no topic specified");
                            }
                        });

                        this.client.on('message', function(topic, message) {
                var msg = {
                                topic: topic,
                                payload: message.toString(),
                                source: 'mqtt'
                };
                node.send(msg);
            });

                        this.client.on('close', function() {
                            if (node.enableMqtt) {
                                node.status({fill:'red', shape:'ring', text:'mqtt disconnected'});
                            } else {
                                node.status({fill:'blue', shape:'dot', text:'input handler'});
                            }
                        });

                        this.client.on('error', function(err) {
                            node.status({fill:'red', shape:'ring', text:'mqtt error'});
                            node.error("MQTT error: " + err.toString());
                        });

                        this.on('close', function(done) {
                            if (node.client) {
                                if (node.topic) {
                    node.client.unsubscribe(node.topic);
                                }
                                node.client.end(true, done);
                            } else {
                                done();
                            }
                        });
                    } else {
                        node.error("Failed to create MQTT client");
                        this.status({fill:'red', shape:'ring', text:'client creation failed'});
                    }
                } catch (err) {
                    node.error("Error creating MQTT client: " + err.toString());
                    this.status({fill:'red', shape:'ring', text:'setup error'});
                }
            } else {
                node.warn("MQTT enabled but broker not configured");
                this.status({fill:'blue', shape:'dot', text:'input only (no broker)'});
            }
        }

        // Override the send function to support conditional connections
        this.on("input", function(msg, send, done) {
            // Apply configured payload if set
            if (node.payload) {
                msg.payload = node.payload;
            }
            
            // Mark message as processed
            msg.processed_by_triplets = true;
            
            // Handle MQTT topic changes if MQTT is enabled
            if (node.enableMqtt && node.client && msg.mqtt_control) {
                if (msg.mqtt_control === 'subscribe' && msg.topic) {
                    // Subscribe to a new topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                        }
                        node.topic = msg.topic;
                        node.client.subscribe(node.topic, {qos: node.qos});
                        node.status({fill:"green", shape:"dot", text:"mqtt: " + node.topic});
                    } catch(err) {
                        node.error("Error changing subscription: " + err.toString());
                    }
                }
                else if (msg.mqtt_control === 'unsubscribe') {
                    // Unsubscribe from current topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                            node.topic = '';
                            node.status({fill:"yellow", shape:"dot", text:"mqtt: no subscription"});
                        }
                    } catch(err) {
                        node.error("Error unsubscribing: " + err.toString());
                    }
                }
            }
            
            // Process with custom function if available
            if (node.processFunction) {
                try {
                    msg = node.processFunction(msg, node);
                } catch(err) {
                    node.error("Error in custom function: " + err.toString(), msg);
                }
            }
            
            // Generate triplets if templates are enabled
            if (node.enableTemplates) {
                var triplets = [];
                var data = (typeof msg.payload === 'object') ? msg.payload : { value: msg.payload };
                
                // Process each template
                node.templates.forEach(function(template) {
                    if (template.subject && template.relation && template.property && data[template.property] !== undefined) {
                        var value = data[template.property];
                        
                        // Convert value based on type if needed
                        switch(template.valueType) {
                            case 'number':
                                value = Number(value);
                                break;
                            case 'boolean':
                                value = Boolean(value);
                                break;
                            case 'date':
                                if (!(value instanceof Date)) {
                                    value = new Date(value);
                                }
                                break;
                            default: // string
                                value = String(value);
                        }
                        
                        // Create the triplet (subject, predicate, object)
                        triplets.push({
                            subject: template.subject,
                            predicate: template.relation,
                            object: value
                        });
                    }
                });
                
                // Add triplets to message
                msg.triplets = triplets;
                
                // Store triplets if enabled
                if (node.enableStorage && node.apiEndpoint && triplets.length > 0) {
                    try {
                        // Create storage request
                        var storageMsg = {
                            url: node.apiEndpoint,
                            method: "POST",
                            payload: {
                                triplets: triplets,
                                storageType: node.storageType,
                                timestamp: new Date().toISOString()
                            }
                        };
                        
                        // Log the storage attempt
                        node.status({fill:"green", shape:"dot", text:"storing triplets"});
                        
                        // Include storage message
                        msg.storageRequest = storageMsg;
                        
                        // Note: The actual API call would need to be handled by an HTTP node
                        // We just prepare the request here
                    } catch(err) {
                        node.error("Error preparing storage: " + err.toString(), msg);
                        node.status({fill:"red", shape:"ring", text:"storage error"});
                    }
                }
            }
            
            // Include prompt and objective if set
            if (node.prompt) {
                msg.prompt = node.prompt;
            }
            
            if (node.objective) {
                msg.objective = node.objective;
            }
            
            // Send the message with support for conditional connections
            // We do this by examining the wiring and checking if any connection has conditions
            var wires = node.wires;
            var outputs = [];
            
            // Prepare outputs array (with empty arrays for each output)
            for (var i = 0; i < wires.length; i++) {
                outputs[i] = [];
            }
            
            // For each output...
            for (var i = 0; i < wires.length; i++) {
                var connections = wires[i];
                
                // For each connection from this output...
                for (var j = 0; j < connections.length; j++) {
                    var targetNodeId = connections[j];
                    var linkId = node.id + ':' + i + ':' + targetNodeId;
                    
                    // Check if this connection has a condition
                    var condition = null;
                    if (RED.contextMenu && typeof RED.contextMenu.getCondition === 'function') {
                        condition = RED.contextMenu.getCondition(linkId);
                    }
                    
                    // If no condition or the condition is not enabled, always send
                    if (!condition || !condition.enabled) {
                        outputs[i].push(targetNodeId);
                        continue;
                    }
                    
                    // Evaluate the condition
                    var result = false;
                    if (RED.contextMenu && typeof RED.contextMenu.evaluateCondition === 'function') {
                        result = RED.contextMenu.evaluateCondition(condition, msg);
                    } else {
                        // Fallback evaluation if the contextMenu API is not available
                        try {
                            // Handle triplet-specific conditions
                            if (condition.useTriplets && msg.triplets && Array.isArray(msg.triplets)) {
                                var subject = condition.tripletSubject;
                                var predicate = condition.tripletPredicate;
                                var object = condition.tripletObject;
                                
                                // Empty condition matches any triplet
                                if (!subject && !predicate && !object) {
                                    result = true;
                                } else {
                                    // Check if any triplet matches the condition
                                    for (var t = 0; t < msg.triplets.length; t++) {
                                        var triplet = msg.triplets[t];
                                        
                                        // Skip invalid triplets
                                        if (!triplet || typeof triplet !== 'object') {
                                            continue;
                                        }
                                        
                                        // Check subject (if specified)
                                        if (subject && triplet.subject !== subject) {
                                            continue;
                                        }
                                        
                                        // Check predicate (if specified)
                                        if (predicate && triplet.predicate !== predicate) {
                                            continue;
                                        }
                                        
                                        // Check object (if specified)
                                        if (object && triplet.object !== object) {
                                            continue;
                                        }
                                        
                                        // If we got here, all specified conditions match
                                        result = true;
                                        break;
                                    }
                                }
                            } else {
                                // Similar logic to evaluateCondition function in contextMenu.js
                                var propertyValue = RED.utils.getMessageProperty(msg, condition.property);
                                
                                // Convert the target value based on its type
                                var targetValue = condition.value;
                                switch (condition.valueType) {
                                    case 'num':
                                        targetValue = Number(targetValue);
                                        break;
                                    case 'bool':
                                        targetValue = (targetValue === 'true' || targetValue === true);
                                        break;
                                    case 'json':
                                        try {
                                            targetValue = JSON.parse(targetValue);
                                        } catch(e) {
                                            // Keep as string if JSON parsing fails
                                        }
                                        break;
                                }
                                
                                // Evaluate based on operator
                                switch (condition.operator) {
                                    case 'eq':
                                        result = propertyValue == targetValue;
                                        break;
                                    case 'neq':
                                        result = propertyValue != targetValue;
                                        break;
                                    case 'lt':
                                        result = propertyValue < targetValue;
                                        break;
                                    case 'lte':
                                        result = propertyValue <= targetValue;
                                        break;
                                    case 'gt':
                                        result = propertyValue > targetValue;
                                        break;
                                    case 'gte':
                                        result = propertyValue >= targetValue;
                                        break;
                                    case 'contains':
                                        result = String(propertyValue).includes(String(targetValue));
                                        break;
                                    case 'startsWith':
                                        result = String(propertyValue).startsWith(String(targetValue));
                                        break;
                                    case 'endsWith':
                                        result = String(propertyValue).endsWith(String(targetValue));
                                        break;
                                    case 'regex':
                                        try {
                                            var regex = new RegExp(targetValue);
                                            result = regex.test(String(propertyValue));
                                        } catch(e) {
                                            result = false;
                                        }
                                        break;
                                    default:
                                        result = true;
                                }
                            }
                        } catch(err) {
                            // If there's an error evaluating the condition, log it and don't send
                            node.warn("Error evaluating condition: " + err.toString());
                            result = false;
                        }
                    }
                    
                    // If the condition passes, add this target to the output list
                    if (result) {
                        outputs[i].push(targetNodeId);
                    }
                }
            }
            
            // Use the send function with our modified outputs
            if (send) {
                // Convert the outputs array to the format expected by send
                var sendOutputs = [];
                for (var i = 0; i < outputs.length; i++) {
                    if (outputs[i].length > 0) {
                        // Only create this output if it has targets
                        if (!sendOutputs[i]) {
                            sendOutputs[i] = msg;
                        }
                    }
                }
                send(sendOutputs);
            } else {
                // Legacy mode for older versions of Node-RED
            node.send(msg);
            }
            
            if (done) {
                done();
            }
        });
    }
    RED.nodes.registerType("triplets", Triplets);
}