module.exports = function(RED) {
    var mqtt = require('mqtt');
    
    function Triplets(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        this.payload = config.payload;
        this.topic = config.topic;
        this.qos = parseInt(config.qos || 0);
        
        // New properties
        this.prompt = config.prompt;
        this.objective = config.objective;
        
        // Knowledge graph triplet templates
        this.templates = config.templates || [];
        
        // Storage options - now just the API endpoint, enableStorage is per template
        this.apiEndpoint = config.apiEndpoint;
        
        // Custom functions
        this.functions = config.functions || [];
        this.functionObjects = [];
        
        // Compile functions
        if (this.functions.length > 0) {
            this.functions.forEach(function(functionDef) {
                try {
                    var functionObject = Function('msg', 'node', 'context', 'flow', 'global', functionDef.code);
                    node.functionObjects.push({
                        name: functionDef.name,
                        func: functionObject
                    });
                } catch(err) {
                    node.error("Error in function '" + functionDef.name + "': " + err.toString());
                    node.warn("Function '" + functionDef.name + "' disabled due to error");
                }
            });
        }
        
        // Default status - MQTT is now always part of the default status
        this.status({fill:'yellow', shape:'ring', text:'connecting to mqtt...'});
        
        // Set up MQTT subscription - always enabled
        this.broker = RED.nodes.getNode(config.broker);

        if (this.broker) {
            try {
                // Instead of using broker.connect(), create our own MQTT client:
                var options = {
                    clientId: 'triplet_' + Math.random().toString(16).substring(2, 8),
                    clean: true
                };
                
                // Get connection details from broker config
                var brokerUrl = 'mqtt://' + this.broker.broker + ':' + this.broker.port;
                
                // Create MQTT client directly
                this.client = mqtt.connect(brokerUrl, options);
                
                if (this.client) {
                    this.client.on('connect', function() {
                        node.status({fill:"green", shape:"dot", text:"mqtt connected"});
                        
                        if (node.topic) {
                            node.client.subscribe(node.topic, {qos: node.qos});
                        } else {
                            node.warn("MQTT topic not specified");
                        }
                    });

                    this.client.on('message', function(topic, message) {
                        try {
                            // Create a new message object from the MQTT message
                var msg = {
                                topic: topic,
                                payload: message.toString()
                            };
                            
                            // Try to parse payload as JSON
                            try {
                                msg.payload = JSON.parse(msg.payload);
                            } catch (parseError) {
                                // If not valid JSON, keep as string
                                node.warn("MQTT message is not valid JSON, using as string");
                            }
                            
                            // Mark message as processed by triplets
                            msg.processed_by_triplets = true;
                            
                            // Process with custom functions first
                            msg = processWithFunctions(msg);
                            
                            // Generate triplets
                            var generatedTriplets = [];
                            var storeTriplets = [];
                            
                            node.templates.forEach(function(template) {
                                if (template.subject && template.predicate && template.object) {
                                    // Generate triplet
                                    var triplet = {
                                        subject: template.subject,
                                        predicate: template.predicate,
                                        object: template.object
                                    };
                                    
                                    // Apply dynamic values if needed
                                    if (typeof msg.payload === 'object') {
                                        for (var key in triplet) {
                                            if (triplet[key].startsWith('msg.')) {
                                                var path = triplet[key].substring(4).split('.');
                                                var value = msg;
                                                
                                                // Navigate the path
                                                for (var i = 0; i < path.length; i++) {
                                                    if (value === undefined || value === null) break;
                                                    value = value[path[i]];
                                                }
                                                
                                                // Set the triplet value if path resolved
                                                if (value !== undefined && value !== null) {
                                                    triplet[key] = value.toString();
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Add to generated triplets
                                    generatedTriplets.push(triplet);
                                    
                                    // Add to store triplets if template has storage enabled
                                    if (template.enableStorage && node.apiEndpoint) {
                                        storeTriplets.push(triplet);
                                    }
                                }
                            });
                            
                            // Add triplets to message
                            if (generatedTriplets.length > 0) {
                                if (!msg.triplets) {
                                    msg.triplets = [];
                                }
                                
                                msg.triplets = msg.triplets.concat(generatedTriplets);
                                
                                // Update the prompt with triplet templates if it exists
                                if (node.prompt) {
                                    msg.prompt = node.prompt;
                                    
                                    // Append each triplet definition to the prompt
                                    generatedTriplets.forEach(function(triplet) {
                                        msg.prompt += "\nTriplet: " + triplet.subject + " - " + triplet.predicate + " - " + triplet.object;
                                    });
                                }
                                
                                // Try to store triplets if any are marked for storage
                                if (storeTriplets.length > 0 && node.apiEndpoint) {
                                    try {
                                        // Prepare storage request with timestamp
                                        var storageRequest = {
                                            triplets: storeTriplets,
                                            timestamp: new Date().toISOString()
                                        };
                                        
                                        // Send storage request
                                        // This would typically be an HTTP request, but we're just logging for now
                                        node.warn("Would store " + storeTriplets.length + " triplets to: " + node.apiEndpoint);
                                        node.status({fill:"blue", shape:"dot", text:"mqtt: storing " + storeTriplets.length});
                                    } catch (storeError) {
                                        node.error("Error storing triplets: " + storeError.toString());
                                    }
                                }
                            }
                            
                            // Include prompt and objective if set (only if not already set by triplets)
                            if (node.prompt && !msg.prompt) {
                                msg.prompt = node.prompt;
                                // Also add to payload for easier access
                                if (typeof msg.payload === 'object') {
                                    msg.payload.prompt = node.prompt;
                                }
                            }
                            
                            if (node.objective) {
                                msg.objective = node.objective;
                                // Also add to payload for easier access
                                if (typeof msg.payload === 'object') {
                                    msg.payload.objective = node.objective;
                                }
                            }
                            
                            // Send the constructed message
                node.send(msg);
                            
                        } catch (err) {
                            node.error("Error processing MQTT message: " + err.toString());
                        }
                    });

                    this.client.on('close', function() {
                        node.status({fill:'red', shape:'ring', text:'mqtt disconnected'});
                    });

                    this.client.on('error', function(err) {
                        node.status({fill:'red', shape:'ring', text:'mqtt error'});
                        node.error("MQTT error: " + err.toString());
                    });

                    this.on('close', function(done) {
                        if (node.client) {
                            if (node.topic) {
                                node.client.unsubscribe(node.topic);
                            }
                            node.client.end(true, done);
                        } else {
                            done();
                        }
                    });
                } else {
                    node.error("Failed to create MQTT client");
                    this.status({fill:'red', shape:'ring', text:'mqtt client creation failed'});
                }
            } catch (err) {
                node.error("Error creating MQTT client: " + err.toString());
                this.status({fill:'red', shape:'ring', text:'mqtt setup error'});
            }
        } else {
            node.error("MQTT broker not configured");
            this.status({fill:'red', shape:'ring', text:'mqtt broker not configured'});
        }

        // Function to process message with custom functions
        function processWithFunctions(msg) {
            if (node.functionObjects && node.functionObjects.length > 0) {
                try {
                    for (var i = 0; i < node.functionObjects.length; i++) {
                        var funcObj = node.functionObjects[i];
                        try {
                            // Call the function with context access
                            var result = funcObj.func(msg, node, node.context(), node.context().flow, node.context().global);
                            
                            // Update the message object if a result was returned
                            if (result !== null && result !== undefined) {
                                msg = result;
                            } else {
                                node.warn("Function '" + funcObj.name + "' did not return a message object");
                            }
                        } catch (err) {
                            node.error("Error in function '" + funcObj.name + "': " + err.toString(), msg);
                            node.warn("Continuing with other functions");
                        }
                    }
                } catch (err) {
                    node.error("Error processing functions: " + err.toString(), msg);
                }
            }
            return msg;
        }

        // Handle normal input flow messages
        this.on("input", function(msg, send, done) {
            // Apply configured payload if set
            if (node.payload) {
                msg.payload = node.payload;
            }
            
            // Mark message as processed
            msg.processed_by_triplets = true;
            
            // Process with custom functions
            try {
                msg = processWithFunctions(msg);
            } catch (err) {
                node.error("Error running custom functions: " + err.toString(), msg);
            }
            
            // Create a text representation of triplet templates to add to the prompt
            var templatesText = "Knowledge Triplet Templates:\n";
            
            node.templates.forEach(function(template) {
                templatesText += `${template.subject} ${template.predicate} [${template.object}]\n`;
            });
            
            // Store the templates text for use in the prompt
            msg.templatesText = templatesText;
            
            // Store the original prompt if set
            var originalPrompt = node.prompt || '';
            
            // If prompt is already set, append the templates
            if (originalPrompt) {
                msg.prompt = originalPrompt + "\n\n" + templatesText;
            } else {
                msg.prompt = templatesText;
            }
            
            // Also add to payload for easier access
            if (typeof msg.payload === 'object') {
                msg.payload.templatesText = templatesText;
                msg.payload.prompt = msg.prompt;
            }
            
            var triplets = [];
            var storeTriplets = []; // Separate array for triplets to be stored
            var data = {};
            
            // Extract data from payload
            if (typeof msg.payload === 'object') {
                data = msg.payload;
            } else if (typeof msg.payload === 'string') {
                try {
                    data = JSON.parse(msg.payload);
                } catch(e) {
                    data = { value: msg.payload };
                }
            } else {
                data = { value: msg.payload };
            }
            
            // Process each template to extract triplets
            node.templates.forEach(function(template) {
                // Extract path from object field if it exists
                if (template.subject && template.predicate && template.object) {
                    var objectPath = template.object;
                    var value;
                    
                    // Handle dynamic paths (msg.payload.something)
                    if (objectPath.startsWith('msg.')) {
                        var path = objectPath.substring(4).split('.');
                        value = msg;
                        
                        // Navigate the path
                        for (var i = 0; i < path.length; i++) {
                            if (value === undefined || value === null) break;
                            value = value[path[i]];
                        }
                    } else {
                        // Try direct access from data
                        value = data[objectPath];
                    }
                    
                    // Create the triplet if value was found
                    if (value !== undefined && value !== null) {
                        // Convert to string if needed
                        if (typeof value !== 'string') {
                            value = value.toString();
                        }
                        
                        var triplet = {
                            subject: template.subject,
                            predicate: template.predicate,
                            object: value
                        };
                        
                        // Add to all triplets array
                        triplets.push(triplet);
                        
                        // If this template has storage enabled, add to the store array
                        if (template.enableStorage && node.apiEndpoint) {
                            storeTriplets.push(triplet);
                        }
                    }
                }
            });
            
            // Add triplets to message for storage and other uses
            msg.triplets = triplets;
            
            // Store triplets that are marked for storage
            if (storeTriplets.length > 0 && node.apiEndpoint) {
                try {
                    // Create storage request
                    var storageMsg = {
                        url: node.apiEndpoint,
                        method: "POST",
                        payload: {
                            triplets: storeTriplets,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                    // Log the storage attempt
                    node.status({fill:"green", shape:"dot", text:"storing triplets: " + storeTriplets.length});
                    
                    // Include storage message
                    msg.storageRequest = storageMsg;
                } catch(err) {
                    node.error("Error preparing storage: " + err.toString(), msg);
                    node.status({fill:"red", shape:"ring", text:"storage error"});
                }
            }
            
            // Include prompt and objective if set (only if not already set by triplets)
            if (node.prompt && !msg.prompt) {
                msg.prompt = node.prompt;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.prompt = node.prompt;
                }
            }
            
            if (node.objective) {
                msg.objective = node.objective;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.objective = node.objective;
                }
            }
            
            // Handle MQTT topic changes - always enabled
            if (node.client && msg.mqtt_control) {
                if (msg.mqtt_control === 'subscribe' && msg.topic) {
                    // Subscribe to a new topic
                    try {
                        if (node.topic) {
                    node.client.unsubscribe(node.topic);
                        }
                        node.topic = msg.topic;
                        node.client.subscribe(node.topic, {qos: node.qos});
                        node.status({fill:"green", shape:"dot", text:"mqtt: " + node.topic});
                    } catch(err) {
                        node.error("Error changing subscription: " + err.toString());
                    }
                }
                else if (msg.mqtt_control === 'unsubscribe') {
                    // Unsubscribe from current topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                            node.topic = '';
                            node.status({fill:"yellow", shape:"dot", text:"mqtt: no subscription"});
                        }
                    } catch(err) {
                        node.error("Error unsubscribing: " + err.toString());
                    }
                }
            }
            
            // Send the message
            if (send) {
                send(msg);
            } else {
                node.send(msg);
            }
            
            if (done) {
                done();
            }
        });
    }
    RED.nodes.registerType("triplets", Triplets);
}