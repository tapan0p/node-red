module.exports = function(RED) {
    "use strict";

    // Comparison operators
    var operators = {
        'eq': function(a, b) { return a == b; },
        'neq': function(a, b) { return a != b; },
        'lt': function(a, b) { return a < b; },
        'lte': function(a, b) { return a <= b; },
        'gt': function(a, b) { return a > b; },
        'gte': function(a, b) { return a >= b; },
        'contains': function(a, b) { return (a + "").indexOf(b) != -1; },
        'startsWith': function(a, b) { return (a + "").startsWith(b); },
        'endsWith': function(a, b) { return (a + "").endsWith(b); },
        'true': function(a) { return a === true; },
        'false': function(a) { return a === false; },
        'null': function(a) { return a === null || typeof a === "undefined"; },
        'not-null': function(a) { return a !== null && typeof a !== "undefined"; },
        'typeof': function(a, b) { return typeof a === b; }
    };

    function ConditionalEdgeNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        
        // Try to add CSS to hide the node label if we're in a browser context
        try {
            if (typeof document !== "undefined") {
                var styleEl = document.createElement('style');
                styleEl.innerHTML = `
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-label,
                    .red-ui-palette-node[data-type="conditional-edge"] .red-ui-palette-label,
                    div[data-type="conditional-edge"] .red-ui-node-label,
                    [data-type="conditional-edge"] span,
                    [data-type="conditional-edge"] text,
                    .conditional-edge-node .node_label { 
                        display: none !important;
                        visibility: hidden !important;
                        opacity: 0 !important;
                        font-size: 0 !important;
                        width: 0 !important;
                        height: 0 !important;
                    }
                    
                    .red-ui-node[data-type="conditional-edge"] {
                        width: 10px !important;
                        min-width: 10px !important;
                        height: 20px !important;
                        border-radius: 5px !important;
                    }
                    
                    /* Adjust port positions for the small node */
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-port {
                        top: 10px !important;
                    }
                    
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-input {
                        left: -5px !important;
                    }
                    
                    .red-ui-node[data-type="conditional-edge"] .red-ui-node-output {
                        right: -5px !important;
                    }
                `;
                document.head.appendChild(styleEl);
            }
        } catch (e) {
            // Ignore errors, we might be in Node.js context
        }
        
        // Remove any name property completely
        delete this.name;
        
        // Set an empty type display name to override the default
        this.type = "\u200B"; // Zero-width space
        
        // Save configuration
        this.property = config.property || "triplets";
        this.propertyType = config.propertyType || "msg";
        this.rules = config.rules || [{t: "eq", v: "", vt: "str"}];
        this.checkall = config.checkall || "true";
        this.target = config.target || "subject";
        this.targetValue = config.targetValue || "";
        
        // Function to parse and evaluate triplet data
        function evaluateTripletRules(msg) {
            // Get the value of the configured property (usually msg.triplets)
            var property;
            try {
                property = RED.util.getMessageProperty(msg, node.property);
            } catch(err) {
                node.warn("Property access error: " + err.toString());
                property = undefined;
            }
            
            // Ensure property contains triplet data
            if (!property || !Array.isArray(property)) {
                node.status({fill:"yellow", shape:"ring", text:"no triplets found"});
                return false; // Return false by default if no triplets
            }
            
            // Filter triplets based on target configuration
            var targetTriplets = property;
            if (node.target !== "all" && node.targetValue) {
                // Filter by subject, predicate, or object value
                targetTriplets = property.filter(function(triplet) {
                    if (node.target === "subject") {
                        return triplet.subject === node.targetValue;
                    } else if (node.target === "predicate") {
                        return triplet.predicate === node.targetValue;
                    } else if (node.target === "object") {
                        return String(triplet.object) === String(node.targetValue);
                    }
                    return true;
                });
            }
            
            if (targetTriplets.length === 0) {
                node.status({fill:"yellow", shape:"ring", text:"no matching triplets"});
                return false;
            }
            
            // Evaluate rules against the filtered triplets
            var matchCount = 0;
            var isMatch = false;
            
            // Process each triplet against the rules
            for (var i = 0; i < targetTriplets.length; i++) {
                var triplet = targetTriplets[i];
                var tripletValue = triplet.object; // The value to compare is typically in object field
                
                // Evaluate each rule
                for (var j = 0; j < node.rules.length; j++) {
                    var rule = node.rules[j];
                    var v1, v2;
                    
                    // Get the value to compare against
                    if (rule.vt === 'str') {
                        v1 = rule.v;
                    } else if (rule.vt === 'num') {
                        v1 = Number(rule.v);
                    } else if (rule.vt === 'bool') {
                        v1 = (rule.v === 'true');
                    } else if (rule.vt === 'msg' || rule.vt === 'flow' || rule.vt === 'global') {
                        // Get value from message or context
                        try {
                            v1 = RED.util.evaluateNodeProperty(rule.v, rule.vt, node, msg);
                        } catch(err) {
                            node.warn("Rule value error: " + err.toString());
                            continue;
                        }
                    }
                    
                    // For rules that need a second value (currently unused but for future flexibility)
                    if (rule.v2t) {
                        if (rule.v2t === 'str') {
                            v2 = rule.v2;
                        } else if (rule.v2t === 'num') {
                            v2 = Number(rule.v2);
                        } else if (rule.v2t === 'msg' || rule.v2t === 'flow' || rule.v2t === 'global') {
                            try {
                                v2 = RED.util.evaluateNodeProperty(rule.v2, rule.v2t, node, msg);
                            } catch(err) {
                                node.warn("Rule value2 error: " + err.toString());
                                continue;
                            }
                        }
                    }
                    
                    // Apply the operator
                    if (operators[rule.t]) {
                        isMatch = operators[rule.t](tripletValue, v1, v2);
                        if (isMatch) {
                            matchCount++;
                            if (node.checkall === "false") {
                                break; // Stop at first match if not checking all
                            }
                        }
                    }
                }
                
                // For a single triplet, if we're checking all rules and we don't have
                // enough matches, this triplet doesn't match all rules
                if (node.checkall === "true" && matchCount < node.rules.length) {
                    isMatch = false;
                }
                
                // If we found a match and we're not checking all triplets, we can stop
                if (isMatch && node.target !== "all") {
                    break;
                }
            }
            
            return isMatch;
        }
        
        // Handle incoming messages
        this.on('input', function(msg, send, done) {
            // For backwards compatibility
            send = send || function() { node.send.apply(node, arguments); };
            
            // Update status
            node.status({fill:"blue", shape:"dot", text:"evaluating"});
            
            try {
                // Evaluate the rules against the triplet data
                var isMatch = evaluateTripletRules(msg);
                
                // Update status based on result
                if (isMatch) {
                    node.status({fill:"green", shape:"dot", text:"condition met"});
                    send(msg); // Forward the message
                } else {
                    node.status({fill:"red", shape:"ring", text:"condition not met"});
                    // Message is not forwarded
                }
                
                if (done) {
                    done();
                }
            } catch(err) {
                // Handle any errors
                if (done) {
                    done(err);
                } else {
                    node.error(err, msg);
                }
            }
        });
    }
    RED.nodes.registerType("conditional-edge", ConditionalEdgeNode);
} 